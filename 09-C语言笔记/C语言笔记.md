# 大体笔记

## VS快捷键

[VS中常用的快捷键](https://blog.csdn.net/mrlisky/article/details/72622009)

* 按F10可以调试代码，一直按F10就可以逐语句调试了。
* F11可以逐语句调试，比F10更细致——可以进入函数体里面去。
* 按F5可以运行项目。
* 搜狗输入法输入`shijian`可以显示日期 + 时间。 
* 点击调试——窗口——监视，可以看到变量的执行过程变化(需要先按F5或F10或F11进行调试,必须要先调试起来才能在窗口里看到更多东西)
* F9可以打断点。

## 单精度和双精度的区别

单精度型和双精度型的区别在于它们的精确程度不一样，也就是小数部分的有效位数不一样。

单精度数（float型）在32位计算机中存储占用4字节，也就是32位，有效位数为7位，小数点后6位；双精度数（double型）在32位计算机中存储占用8字节，也就是64位，有效位数为16位，小数点后15位。

比如3.1415926535897932384这个小数，如果定义成float型，那么只会留下小数点后5位，也就是3.141592，如果定义成double型，那么只会留下小数点后15位，也就是3.141592653589793。

![](C语言笔记/01.png)

## size_t类型

在C语言中，size_t是一种无符号整数类型，通常用于表示内存中对象的大小或元素的数量。它的大小取决于编译器和操作系统的位数，通常是32位或64位。

size_t类型通常用于以下情况：

1. 用于表示内存中对象的大小，例如malloc函数返回的指针所指向的内存块的大小。

2. 用于表示数组或缓冲区的元素数量，例如strlen函数返回的字符串长度。

3. 用于表示文件或流中的字节数量，例如fread函数读取的字节数。

使用size_t类型可以确保在不同平台上的程序的可移植性和正确性。

## 结构体

**疑问**：C语言中定义一个结构体，在结构体内部定义结点的指针域，类型这个是结构体类型，这个为什么不会导致循环定义？因为这个结构体还没定义完，为什么可以在结构体内部使用这个结构体类型呢

**回答**：结构体是嵌套定义的。结构体是没有递归的，因为如果你结构体套用递归的话，你将无法判断结构体所占内存的大小。**编译器读程序是从上到下的，读到第一行结构体类型定义时，会假定这个结构体类型已经存在，于是下面就可以使用这个类型。**

在C语言中，结构体的定义是可以分开进行的。也就是说，我们可以先定义一个结构体类型的名称，然后再在结构体内部使用这个名称来定义结构体的成员。

例如，下面的代码定义了一个结构体类型Node，其中包含一个指向Node类型的指针next：

```c
struct Node;
typedef struct Node Node;

struct Node {
    int data;
    Node *next;
};
```

**在这个例子中，我们先定义了一个Node类型的名称，然后在结构体内部使用了这个名称来定义next成员。由于我们已经定义了Node类型的名称，所以在结构体内部使用这个名称不会导致循环定义的问题。**

需要注意的是，如果我们在结构体内部直接使用结构体类型的名称而没有先定义这个名称，就会导致循环定义的问题。例如，下面的代码就会导致编译错误：

```c
struct Node {
    int data;
    struct Node *next; // 错误：结构体类型未定义
};
```

因为在结构体内部使用了未定义的结构体类型名称。