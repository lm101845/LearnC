/**
	2022年1月1日 
*/

/**
	动态内存分配：
		传统数组的缺点：
			1.数组长度必须事先制定，且只能是常整数，不能是变量
				例子：
					int a[5];   OK
					int len = 5;
					int a[len];    Error (备注：老师录制的时间很早，当时的C标准确实是不行的，现在C语言已经允许定义可变长度的数组了) 
			2.传统形式定义的数组，该数组的内存程序员无法手动释放它(数组定义后，是静态分配内存空间的,只能在程序运行结束后释放) 
			  数组一旦定义，系统为该数组分配的存储空间就会一直存在，除非数组所在的函数运行结束
			  在一个函数运行期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会释放 
			
			3.数组的长度一旦定义，其长度就不能再更改了 
			数组的长度不能在函数运行的过程中动态的扩充或缩小(注：C99中现在可以了) 
			
			4.A函数定义的数组在A函数运行期间可以被其他函数使用，
			  但A函数运行完毕之后，A函数中的数组将无法再被其他函数使用 
			  总结：传统方式定义的数组不能跨函数使用 
					
		为什么需要动态分配内存
			动态数组很好的解决了传统数组的这4个缺陷
			传统数组也叫【静态数组】 
			
		动态内存分配举例――动态数组的构造
		静态分配内存和动态内存的比较
		跨函数使用内存的问题 
*/

#include<stdio.h>

void g(int* pArr, int len)
{
	pArr[2] = 88;
	//因为你把a的值发送给了pArr了，所以pArr[2] === a[2]	
} 

void f(void)
{
	int a[5] = {1,2,3,4,5};    
	//这20个字节的存储空间程序员无法手动编程释放它，它只能在本函数运行完毕时由系统自动释放 
	g(a,5); 
	//把数组的首地址a发送给了g函数的形参pArr 
	printf("%d\n",a[2]); 
	
	//当f函数运行完毕之后，里面的数组就无法被其他函数所使用了――因为里面的数组被释放了
	//即f里面的内存不能跨函数使用 
	
} 
int main(void)
{
	f(); 
} 

