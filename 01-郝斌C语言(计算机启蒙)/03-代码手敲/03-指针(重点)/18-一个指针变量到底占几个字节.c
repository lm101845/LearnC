/**
	2022年1月1日 
*/


/**
	假设p指向char类型变量(1个字节) 
	假设q指向int类型变量(4个字节)
	假设r指向double类型变量(8个字节) 
*/

/**
	预备知识：
		sizeof(数据类型)
			功能：返回值就是该数据类型所占的字节数 
			例子：sizeof(int) = 4;  sizeof(char) = 1;  sizeof(double) = 8; 
			备注：sizeof是一个【运算符】，是用来计算运算对象所占内存大小的，不是调用 
		sizeof(变量名)
			功能：返回值是该变量所占的字节数 
*/
#include <stdio.h>

int main(void)
{
	char ch = 'A';
	int i = 99;
	double x = 66.6;   
	//x有8个字节，有8个编号，到底哪个编号算x的地址呢？？？？？ 
	//方法1：以首字节算它的编号
	//方法2：以末字节算它的编号
	//方法3: 8个字节都算它的编号	
	
	char* p = &ch;
	int* q = &i;
	//思考：q等于i的地址，q指向i，我们以前讲过，*q代表的是i本身，而不是i的第一个字节。
	//但是q只存放了i(总共有4个字节)的第一个字节的地址，那*q为什么指向了4个字节呢？ 它是怎么做到的？？？？ 
	
	//一个变量占4个字节，我们不可能把这4个字节的地址编号全保存起来，我们只保存第一个字节的地址编号
	//但是你只保存了第一个字节的地址编号，你怎么能指向4个字节呢？？？？
	
	//这个是靠什么区分的呢？？是靠变量类型区分的。 
	
	
	
	 
	double* r = &x;
	
	printf("%d %d %d\n",sizeof(ch),sizeof(i),sizeof(x)); 
	printf("%d %d %d\n",sizeof(p),sizeof(q),sizeof(r));    
	//8 8 8  (如果你电脑是64位，显示888，如果你电脑是32为，显示444) 
	//64位系统显示444的原因是你的编译器选择了x86环境，也就是32位环境导致的 
	// 说明一个指针变量，无论它指向的那个普通变量到底占几个字节，它本身的大小都不变，都是8(或4)个字节 
	//因为地址是64位的数据，一个字节只能保存8位数据，所以需要8个字节来存放 
	// 即：不管一个变量是1个字节，4个字节还是8个字节，变量的地址都是根据第一个字节的地址确定的，而第一个字节的地址需要用8个字节来表示 
	//比如我有10000个小房子，我要给它编号，虽然房子很小，但是因为它的数量多，所以它的编号就比较大
	
	//CPU要访问内存，它有32(64)根线,这32根线，它有2的32次方个状态，不同的状态能够确定一个单元，所以32位系统最大就是4G(2的32次方)
	//所以地址的编号需要用32根线，比如第一根线是32个0。
	//一个地址需要32位，一个字节是8位，所以需要4个字节才能确定一个地址。 
	
	//注意：我们硬件上的最小单元是一个【字节】，不是一个比特
	//我们一个字节就给它一个编号(即8个01就给它一个编号) 
	
	//8个字节意味着里面有8个编号 
	
	//总结：一个指针变量，无论它指向的变量占几个字节，该指针变量本身只占8(4)个字节 
	//指针变量占8(4)个字节，与它是什么数据类型无关。
	//指针变量存放的是地址啊，长度就取决于地址长度，最大的那个地址占8(4)个字节， 所以长度就需要8(4)个字节 
	return 0;
} 


