/**
	2021年12月25日 merry christmas 
*/

#include <stdio.h>

void f(int* pArr, int len)
{
	pArr[3] = 88;	
	// pArr[3]等价于*(pArr + 3) 
	//p[i]永远等价于*(p+i)
	//总结：*(pArr+i) === pArr[i] === a[i]  === *(a+i) 
} 
int main(void)
{
	int a[6] = {1,2,3,4,5,6};
	printf("%d\n",a[3]);    //4 
	f(a,6);  //第二个参数你可以随便写，写10000也是可以的，运行没问题，但是逻辑上有问题，这个叫下标越界 
	printf("%d\n",a[3]);   //88 
	printf("%d\n",&a[3]);   //6487564
	//&a[3]表示的是a[3]所代表的那个变量的编号的 10进制的表示 
	
	/*
	*a本身代表的就是数组的第一个地址,你把a发送给pArr,它的值就变成一样了，a和pArr代表的都是数组的第一个地址 
	*a和pArr是两个不同的【变量????】，只不过类型一致，里面的内容一样。也可以说pArr是a的一份拷贝 
	*一定要明白，a[3]和pArr[3]是同一个变量。
	*指针变量互相之间不可以相加，但这里指针加的是常数 
	*a和pArr都是数组名，数组名存放的是第一个元素的地址 
	*
	*为什么a[3]是第4个元素？？就是因为a[3]等价于*(a+3)!!!!   哦，原来是这样啊！！！！！！ 
	*a+3表示第4个元素地址，则*(a+3)代表的就是第4个元素
	*请记住：指针是双向传递的
	*
	*
	*直接用指针去实现数组，并且保留了一些似乎有些违法的操作，使得C语言中指针和数组两者模糊了
	*数组和指针本来应该是不同的东西，但是创造C语言的时候创造者懒了一点 
	*/ 
	return 0; 
} 
